# Project Post Week 6

Last week, I achieved my main goal of setting up database migrations to be more structured and easier to reason about. Specifically, I set up the tool Atlas ([website](https://atlasgo.io) / [repository](https://github.com/ariga/atlas)) for the project. The way that I will be using it (as documented in the backend `justfile`) is that I will maintain a centralized `schema.sql` which I edit by hand, and then have Atlas automatically generate migrations whenever I make a change to the schema. This way, the project can have both a proper history of migrations and a single source of truth schema.

I also started to work on automating the creation of seed data, but found it to be a bit more involved than I expected. I encountered several new considerations, such as having multiple entrypoints (binaries), maintaining a basic level of dummy user security (in case I use this dummy data for demonstration in a production environment), and creating date and time data deterministically and reliably. The nature of the dummy data itself also affects how well it is able to show off my app's capabilities.

Accordingly, the primary task for this week will be completing the seed data process. I have the basic flow figured out, but will need to implement some date and time utilities and create the dummy data for the post domain, which will have more dummy data than the user and friendship domains. After that, I will be able to get a more concrete sense of the look and feel of the app with the dummy data in place, and may make some adjustments to the amount and/or content.

The main impediment I currently have is the workload of another class being particularly heavy at the moment. However, this should begin to let up somewhat starting this weekend and significantly by the time I write my next post. I still expect to be able to dedicate sufficient time to this project.

As for my process, I found myself needing to strike a balance between learning interesting concepts and pragmatically advancing the project. For example, I started exploring the idea of reading certain environment variables at compile time instead of runtime where appropriate and ways of incorporating that into the development and build processes. Since I find these technical concerns to be the most interesting parts, and the ultimate goal of the project is learning, I think it can be valid to slow down a bit and not make every decision based on shipping as fast as possible. On the other hand, there's a lot of value in expanding what I can tangibly present as a finished product, and performance optimizations in my data seeding is most likely not the level at which this project will ever be evaluated. Moving forward, I hope to continue to improve my ability to strike a balance between exploring my technical curiosities and moving toward tangible finish lines.

